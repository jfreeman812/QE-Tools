'''
Common decorators for decorating OpenCafe test fixtures and test methods.


**Skipping Tests**

A number of these decorators are designed to utilize the ``unittest.skip``
decorator, or the the ``SkipTest`` exception, both of which skip a test
method or test class for a specific reason.


**Docstring Hacking**

By default, these decorators manipulate the original docstring of the
decorated test class to include additional information in the summary
line.

This is designed to include the current state of a test in the test
documentation autogenerated by Sphinx.

For example, if a test is decorated like so::

    @quarantined('JIRA-123')
    def example_test(self):
        """This is an example description of the test."""
        self.fail()

Then when Sphinx generates documentation for this test case, the HTML
will actually show as if the test case were documented like this::

    @quarantined('JIRA-123')
    def example_test(self):
        """This is an example description of the test. (Quarantined: JIRA-123)"""
        self.fail()

If documentation is autogenerated on a merge to master, and a test is
decorated with that same merge, then the documentation will always show
the most up to date status of each test case.

This feature can be disabled by adding the following lines to your
Sphinx ``conf.py`` file::

    # Disable test method docstring hacking in decorators
    from qe_tools.opencafe import decorators
    decorators.disable_docstring_hacking()


**Applying Decorators To Specific Environments**

Most of the decorators in this module can be applied to only specified
environments. This is useful if say a test is only broken in the staging
environment.

In order to utilize this functionality, your OpenCafe test fixture must
tell the decorators how to know in which environment the tests are currently
being executed.

A specific method must be implemented on the test fixture that takes a
single string argument, and it should return a boolean value that shows
whether or not the given string argument value matches the name of the
environment in which OpenCafe tests are currently being executed.

The name of this method must match the ``ENVIRONMENT_MATCHING_METHOD_NAME``
constant defined in this module.
'''

from inspect import isclass
from unittest import skip
import wrapt


from unittest_decorators import (quarantined, needs_work, nyi,
                                 only_in, production_only,
                                 not_tested, disable_docstring_hacking,
                                 staging_only, unless_coverage)

from unittest_decorators import (TICKET_RE, STATUS_TAGS, _print_and_raise,
                                 _get_coverage_tags_from, _all_ticket_ids_in,
                                 _environment_matches, _docstring_hacking_enabled,
                                 _add_text_to_docstring_summary_line, _tags_log_info)

from cafe.drivers.unittest.decorators import tags as _cafe_tags
# OpenCafe doesn't provide a way to reset tags :-(, so we have to import
# these attribute names so that we don't have to duplicate them.
from cafe.drivers.unittest.decorators import (TAGS_DECORATOR_TAG_LIST_NAME,
                                              PARALLEL_TAGS_LIST_ATTR)


###########
# HELPERS #
###########


def _clear_cafe_tags_from(func):
    '''Clear out all the cafe tags on func'''
    for attr in (TAGS_DECORATOR_TAG_LIST_NAME, PARALLEL_TAGS_LIST_ATTR):
        if hasattr(func, attr):
            delattr(func, attr)


def _add_tags(func, cafe_tags=tuple(), coverage_tags=tuple()):
    '''
    Add the given tags to the given function, both cafe tags and coverage tags.

    Args:
        func: the function to decorate with tagging information.
        cafe_tags: iterable of cafe tags to add to func.
        coverage_tags: iterable of coverage tags to add to func.

    Returns:
        The decorated function.
    '''
    func = _cafe_tags(*cafe_tags)(func)
    _get_coverage_tags_from(func).extend(coverage_tags)
    return func


def _cafe_tag_prefix(status_tag, target_tag):
    '''Optionally prefix target_tag with status_tag to work-around OpenCAFE tag filtering.

    Args:
        status_tag (str): the status tag to be used as a prefix, if needed.
        target_tag (str): another tag to be potentially mutated.

    Returns:
        cafe-friendly version of target_tag
    '''

    if (target_tag == status_tag) or TICKET_RE.match(target_tag):
        return target_tag
    return '{}-{}'.format(status_tag, target_tag)


def _mutate_tags_for_cafe(tags_list):
    '''Implement the tag mutation as described in the `tags` decorator.

    Args:
        tags_list (iterable of str): The list of tags to (potentially) mutate.

    Returns:
        List of (potentially) mutated tags

    Raises:
        ValueError if more than one Status tag has been used.
    '''

    actual_status_tags = set(tags_list) & STATUS_TAGS

    # If there are no status tags in use, there is no need to mutate any
    # of the tags, so we can use them just as they are.
    if not actual_status_tags:
        return tags_list

    if len(actual_status_tags) > 1:
        overlapping_tags = sorted(actual_status_tags)
        msg = 'Conflicting Status tags, only one permitted: {}'.format(', '.join(overlapping_tags))
        _print_and_raise(ValueError, msg)

    status_tag = actual_status_tags.pop()
    new_tags = []
    for a_tag in tags_list:
        new_tags.append(_cafe_tag_prefix(status_tag, a_tag))
    return new_tags


def _get_decorator_for_skipping_test(reason, details, tag_name, environment_affected=''):
    '''
    Get a decorator that skips a test for a specific reason.

    If an ``environment_affected`` value is provided, then the decorator will
    only be applied if the provided value matches the environment being tested.
    Otherwise, it will assume that the decorator should be applied no matter the
    environment.

    Note:
        If an ``environment_affected`` value is provided to the original decorator,
        then an environment matching method **MUST** be implemented on the test fixture.
        The details string must contain one or more Ticket IDs that provide traceability for
        why this test would be skipped.

    Args:
        reason (str): The short reason why the test should be skipped.
        details (str): More details on the specific reason a test is being skipped.
        tag_name (str): The name of the OpenCafe tag that should be applied with the decorator.
        environment_affected (str): The specific environment that is affected by this decorator.
            If none is provided, the decorator is applied no matter the environment.

    Returns:
        A decorator function into which to pass the test case or test class.

    Raises:
        ValueError: If the details string does not contain something that resembles a Ticket ID.
    '''

    ticket_ids = _all_ticket_ids_in(details)
    if not ticket_ids:
        _print_and_raise(ValueError, '"{0}" does not contain any Ticket IDs.'.format(details))

    if environment_affected:
        message = '{0} (in {1} environment): {2}'.format(reason, environment_affected, details)
    else:
        message = '{0}: {1}'.format(reason, details)

    def decorator(test_case_or_class):
        '''The decorator with which to decorate the test case or class.'''
        tags = [tag_name] + ticket_ids
        test_case_or_class = _add_tags(test_case_or_class, cafe_tags=tags, coverage_tags=tags)

        if isclass(test_case_or_class):
            if not environment_affected or _environment_matches(test_fixture=test_case_or_class,
                                                                environment=environment_affected):
                return skip(message)(test_case_or_class)

            return test_case_or_class

        # A class method is being decorated
        if _docstring_hacking_enabled:
            test_case_or_class.__doc__ = _add_text_to_docstring_summary_line(
                original_docstring=test_case_or_class.__doc__, summary_line_addition=message)

        @wrapt.decorator
        def wrapper(wrapped, instance, args, kwargs):
            '''The replacement logic for the original test case or class.'''
            if not environment_affected or _environment_matches(test_fixture=instance,
                                                                environment=environment_affected):
                return skip(message)(wrapped)(*args, **kwargs)

            return wrapped(*args, **kwargs)

        return wrapper(test_case_or_class)

    return decorator


##############
# DECORATORS #
##############


def tags(*tags_list):
    '''
    Create a decorator that applies the given `tags_list` tags to the decorated function.

    Args:
        tags_list (tuple): tags to be added.

    Returns:
        A decorator function that will add the given tags.

    NOTE:
        This decorator generator must be outermost of all the decorators in this file.

        This decorator generator will also mutate the cafe tags so that anything other
        than the status tag and a ticket tag will have a non-operational status tag prepended to it.
        This is overcome a limitation in the cafe test runner that cannot use tags to exclude tests.
        So to accomplish this, a test that is tagged with both 'nyi' and 'regression' will have its
        cafe tags changed to be 'nyi' and 'nyi-regression' so that any test run as `-t regression`
        will _not_ be able to select this test. This is handy, esp. in the case of quarantined tags
        where it might be desirable to run quarantined-smoke tests on a regular basis. It seems
        unlikely that running nyi-<anything> tests would be useful, but it would be possible.

        Any ticket tags must start with the full ID, e.g. 'JIRA-123' otherwise the non-operational
        status tag will be prepended to it, as described above.
    '''

    tags_list = list(tags_list)  # make sure it is a re-usable iterable.

    def tag_decorator(func):
        total_tags = _get_coverage_tags_from(func) + tags_list
        cafe_tags = _mutate_tags_for_cafe(total_tags)
        _clear_cafe_tags_from(func)

        func = _add_tags(func, cafe_tags=cafe_tags, coverage_tags=tags_list)

        return _tags_log_info(func)

    return tag_decorator
